{"name":"ParmEd","tagline":"CHARMM OpenMM Examples","body":"# Examples using CHARMM Files\r\n\r\nThere are popular ways to model biomolecular systems.  Because solvation effects are often (always?) critically important to biological function, we need some way to model the solvent.  The two popular approaches are to employ a continuum model with a dielectric constant equal to that of the bulk solvent or to model the solvent models directly in your system.  These two approaches are termed _implicit_ and _explicit_ solvation, respectively.\r\n\r\nThe next 2 sections present examples using a Generalized Born implicit solvent model and explicit solvent based on the TIP3P water model. All of the files and examples here are included in the `examples/charmm` directory of the ParmEd release.\r\n\r\n## Generalized Born Implicit Solvent\r\n\r\nFor the purposes of this example, we are using an alanine pentapeptide.  You can download the files using the following links (or see the same files in the `examples/charmm` directory of the ParmEd release):\r\n* [ala5_autopsf.psf](ala5_autopsf.psf) : The VMD-generated PSF file\r\n* [ala5_autopsf.pdb](ala5_autopsf.pdb) : The corresponding PDB coordinate file\r\n\r\nThe following sample script (`simulate_charmm_gb.py` in the ParmEd release) will set up and run the simulation using OpenMM:\r\n\r\n```\r\n#!/usr/bin/env python\r\nfrom __future__ import division, print_function\r\n\r\nimport sys\r\n\r\n# OpenMM Imports\r\nimport simtk.unit as u\r\nimport simtk.openmm as mm\r\nimport simtk.openmm.app as app\r\n\r\n# ParmEd Imports\r\nfrom chemistry.charmm.openmmloader import (OpenMMCharmmPsfFile as CharmmPsfFile,\r\n                                           OpenMMCharmmCrdFile as CharmmCrdFile)\r\nfrom chemistry.charmm.parameters import CharmmParameterSet\r\nfrom chemistry.amber.openmmreporters import (\r\n            AmberStateDataReporter as AKMAStateDataReporter)\r\n\r\n# Load the CHARMM files\r\nprint('Loading CHARMM files...')\r\nparams = CharmmParameterSet('toppar/par_all36_prot.prm')\r\nala5_gas = CharmmPsfFile('ala5_autopsf.psf')\r\nala5_crds = app.PDBFile('ala5_autopsf.pdb')\r\n\r\n# Create the OpenMM system\r\nprint('Creating OpenMM System')\r\nsystem = ala5_gas.createSystem(params, nonbondedMethod=app.NoCutoff,\r\n                               constraints=app.HBonds, implicitSolvent=app.HCT,\r\n                               implicitSolventSaltConc=0.1*u.moles/u.liter,\r\n)\r\n\r\n# Create the integrator to do Langevin dynamics\r\nintegrator = mm.LangevinIntegrator(\r\n                        300*u.kelvin,       # Temperature of heat bath\r\n                        1.0/u.picoseconds,  # Friction coefficient\r\n                        2.0*u.femtoseconds, # Time step\r\n)\r\n\r\n# Define the platform to use; CUDA, OpenCL, CPU, or Reference. Or do not specify\r\n# the platform to use the default (fastest) platform\r\nplatform = mm.Platform.getPlatformByName('CUDA')\r\nprop = dict(CudaPrecision='mixed') # Use mixed single/double precision\r\n\r\n# Create the Simulation object\r\nsim = app.Simulation(ala5_gas.topology, system, integrator, platform, prop)\r\n\r\n# Set the particle positions\r\nsim.context.setPositions(ala5_crds.positions)\r\n\r\n# Minimize the energy\r\nprint('Minimizing energy')\r\nsim.minimizeEnergy(maxIterations=500)\r\n\r\n# Set up the reporters to report energies and coordinates every 100 steps\r\nsim.reporters.append(\r\n        AKMAStateDataReporter(sys.stdout, 100, step=True, potentialEnergy=True,\r\n                              kineticEnergy=True, temperature=True,\r\n                              volume=True, density=True)\r\n)\r\nsim.reporters.append(app.DCDReporter('ala5_gb.dcd', 100))\r\n\r\n# Run dynamics\r\nprint('Running dynamics')\r\nsim.step(10000)\r\n```\r\n\r\nNow we'll dissect the script to help you understand what is happening at each step.  We will divide the script into the sections following the ``print`` statements that announce when each stage begins.\r\n\r\n### Loading CHARMM files\r\n\r\nIn this stage, we instantiate the `CharmmParameterSet` with the parameters we wish to use. In this example we are using the CHARMM 36 force field, but be sure you check [the CHARMM parameter website](http://mackerell.umaryland.edu/CHARMM_ff_params.html) to make sure you use the latest and greatest force fields for your own work.\r\n\r\nWe also define the `CharmmPsfFile` object that stores all information about atom connectivity.  The coordinates from PSF files generated by VMD are typically given in PDB format, so we use the OpenMM `PDBFile` object.\r\n\r\n### Create the OpenMM system\r\n\r\nThis command creates an OpenMM `System` object from the information stored in `ala5_gas`. It contains multiple `Force` instances for the bonds, angles, periodic torsions, improper torsions, Urey-Bradley forces, CMAP potentials, and nonbonded (electrostatic and van der Waals) interactions.  It is in this function that we define the potential parameters we want to use. In this example, we have chosen the default values for each parameter except the ones specified. In particular:\r\n* `params` is the parameter set we defined: this is necessary to apply parameters to your system.\r\n* `nonbondedMethod=app.NoCutoff` indicates we do not want to use a cutoff for nonbonded interactions\r\n* `constraints=app.HBonds` indicates that we want to constrain all bonds in which at least one atom is hydrogen\r\n* `implicitSolvent=app.HCT` indicates that we want to use the Hawkins Cramer Truhlar GB model described in Hawkins et al., Chem. Phys. Lett., 1995, 51, p. 19824-19839.\r\n* `implicitSolventSaltConc=0.1*u.liters/u.mole` indicates that we want to model a ca. 0.1 molar solution of monovalent ions using a Debye screening model.\r\n\r\nSee the API documentation for the `chemistry` package ([available here](../../chemistry/chemistry.charmm.html#module-chemistry.charmm.openmmloader)) for a full listing of available options.  If there are any other force objects you want to define, they can be added to the system after this step (like, for instance, positional restraints to a reference structure).\r\n\r\n### Create the integrator to do Langevin Dynamics\r\n\r\nIn this stage we specify an integrator. Common choices are `LangevinIntegrator` (as we've chosen here) to do simulations in the NVT ensemble and `VerletIntegrator` that allows us to do simulations either at constant energy or temperature if using the `AndersenThermostat`.  In this example, we've chosen the Langevin integrator with a target temperature of 300 K, a friction coefficient of 1/ps and a time step of 2 fs.\r\n\r\n### Define the platform\r\n\r\nIn this stage, we define the platform we want to use.  In this example we have chosen the CUDA platform, but this may not be available on every machine since it only runs on NVidia GPU hardware.  Other choices are OpenCL (which will run on a variety of GPUs including those made by AMD/ATI and CPUs), CPU (which is an optimized version that runs natively on CPUs), and Reference (often quite slow).\r\n\r\nThe properties can be set for each platform. In this case, we specified that we wanted to use a mixed precision model (a good compromise between speed and precision).\r\n\r\n### Create the Simulation object\r\n\r\nThis step creates a `Simulation` object that will be used to run the actual simulations.  If we wanted OpenMM to simply pick the fastest platform for us (rather than specify one directly), we could omit the \r\n`platform` and `prop` arguments.\r\n\r\n### Set the particle positions\r\n\r\nThis stage is very important.  In this step, we set the particle positions stored in the `ala5_crds` object to our object.  If you omit this step, you can get strange results or other errors like segmentation violations.  These particle positions have been parsed from the PDB file, but you could use a `CharmmCrdFile` or `CharmmRstFile` (restart file) instead.\r\n\r\n### Minimize the energy\r\n\r\nThis stage performs a basic energy minimization to relax particle positions.  This particular invocation will perform at most 500 iterations.\r\n\r\n### Set up the reporters\r\n\r\nThis stage defines reporters that will \"report\" on the status of the simulation periodically throughout the simulation. The first is an `AKMAStateDataReporter` which will print out a summary of energies and temperatures every 100 steps.  Unlike the `StateDataReporter` in OpenMM, this reporter prints values in the AKMA unit system (Angstrom, Kilocalorie per mole, and atomic mass units).  This reporter directs the printout to standard output (the screen), `sys.stdout` can be replaced with a different file-like object or a file name.\r\n\r\nThe second reporter is a DCD trajectory reporter, which is written in the standard DCD trajectory format.\r\n\r\n### Running dynamics\r\n\r\nThis is the stage that actually runs the MD.  In this case, we are running 10,000 steps of MD.  The wiki page with \"Common recipes\" has information regarding running a long simulation in chunks.\r\n\r\n## Explicit solvent\r\n\r\nFor the purposes of this example, we are using an alanine dipeptide solvated in a box of water.  You can download the files using the following links (or see the same files in the `examples/charmm` directory of the ParmEd release):\r\n* [ala2_charmmgui.psf](ala2_charmmgui.psf) : The input PSF file\r\n* [ala2_charmmgui.crd](ala2_charmmgui.crd) : The input CHARMM coordinate file\r\n\r\nThe following sample script (`simulate_charmm_gui.py` in the ParmEd release) will set up and run the simulation using OpenMM:\r\n\r\n```\r\n#!/usr/bin/env python\r\nfrom __future__ import division, print_function\r\n\r\nimport sys\r\n\r\n# OpenMM Imports\r\nimport simtk.unit as u\r\nimport simtk.openmm as mm\r\nimport simtk.openmm.app as app\r\n\r\n# ParmEd Imports\r\nfrom chemistry.charmm.openmmloader import (OpenMMCharmmPsfFile as CharmmPsfFile,\r\n                                           OpenMMCharmmCrdFile as CharmmCrdFile)\r\nfrom chemistry.charmm.parameters import CharmmParameterSet\r\nfrom chemistry.amber.openmmreporters import (\r\n            AmberStateDataReporter as AKMAStateDataReporter)\r\n\r\n# Load the CHARMM files\r\nprint('Loading CHARMM files...')\r\nparams = CharmmParameterSet('toppar/par_all36_prot.prm',\r\n                            'toppar/toppar_water_ions.str')\r\nala2_solv = CharmmPsfFile('ala2_charmmgui.psf')\r\nala2_crds = CharmmCrdFile('ala2_charmmgui.crd')\r\n\r\n# Compute the box dimensions from the coordinates and set the box lengths (only\r\n# orthorhombic boxes are currently supported in OpenMM)\r\ncoords = ala2_crds.positions\r\nmin_crds = [coords[0][0], coords[0][1], coords[0][2]]\r\nmax_crds = [coords[0][0], coords[0][1], coords[0][2]]\r\n\r\nfor coord in coords:\r\n    min_crds[0] = min(min_crds[0], coord[0])\r\n    min_crds[1] = min(min_crds[1], coord[1])\r\n    min_crds[2] = min(min_crds[2], coord[2])\r\n    max_crds[0] = max(max_crds[0], coord[0])\r\n    max_crds[1] = max(max_crds[1], coord[1])\r\n    max_crds[2] = max(max_crds[2], coord[2])\r\n\r\nala2_solv.setBox(max_crds[0]-min_crds[0],\r\n                 max_crds[1]-min_crds[1],\r\n                 max_crds[2]-min_crds[2],\r\n)\r\n\r\n# Create the OpenMM system\r\nprint('Creating OpenMM System')\r\nsystem = ala2_solv.createSystem(params, nonbondedMethod=app.PME,\r\n                                nonbondedCutoff=6.0*u.angstroms,\r\n                                constraints=app.HBonds,\r\n)\r\n\r\n# Create the integrator to do Langevin dynamics\r\nintegrator = mm.LangevinIntegrator(\r\n                        300*u.kelvin,       # Temperature of heat bath\r\n                        1.0/u.picoseconds,  # Friction coefficient\r\n                        2.0*u.femtoseconds, # Time step\r\n)\r\n\r\n# Define the platform to use; CUDA, OpenCL, CPU, or Reference. Or do not specify\r\n# the platform to use the default (fastest) platform\r\nplatform = mm.Platform.getPlatformByName('CUDA')\r\nprop = dict(CudaPrecision='mixed') # Use mixed single/double precision\r\n\r\n# Create the Simulation object\r\nsim = app.Simulation(ala2_solv.topology, system, integrator, platform, prop)\r\n\r\n# Set the particle positions\r\nsim.context.setPositions(ala2_crds.positions)\r\n\r\n# Minimize the energy\r\nprint('Minimizing energy')\r\nsim.minimizeEnergy(maxIterations=500)\r\n\r\n# Set up the reporters to report energies and coordinates every 100 steps\r\nsim.reporters.append(\r\n        AKMAStateDataReporter(sys.stdout, 100, step=True, potentialEnergy=True,\r\n                              kineticEnergy=True, temperature=True,\r\n                              volume=True, density=True)\r\n)\r\nsim.reporters.append(app.DCDReporter('ala2_solv.dcd', 100))\r\n\r\n# Run dynamics\r\nprint('Running dynamics')\r\nsim.step(10000)\r\n```\r\n\r\nNow we'll dissect the script to help you understand what is happening at each step.  We will divide the script into the sections following the ``print`` statements that announce when each stage begins.\r\n\r\n### Loading CHARMM files\r\n\r\nIn this stage, we instantiate the `CharmmParameterSet` with the parameters we wish to use. In this example we are using the CHARMM 36 force field, but be sure you check [the CHARMM parameter website](http://mackerell.umaryland.edu/CHARMM_ff_params.html) to make sure you use the latest and greatest force fields for your own work.  Note that we also need to load the stream file with the water and ion parameters. The file type detection (RTF, parameter, or stream) is done by file-name extension (or the beginning of the file name if the file names end in `.inp`).\r\n\r\nWe also define the `CharmmPsfFile` object that stores all information about atom connectivity.  The coordinates from PSF files generated by CHARMM GUI are given in the CHARMM coordinate format, so we use the `CharmmCrdFile` class to parse it.\r\n\r\n### Compute the box dimensions\r\n\r\nIn this step, we compute the box dimensions by calculating the extent of the coordinates in each of the X-, Y-, and Z-directions. Then the call to `ala2_solv.setBox` sets the periodic box vectors. You can optionally put the three angles between the lattice vectors (`alpha`, `beta`, and `gamma`) after the box lengths. The default angles are 90 degrees, since OpenMM only supports orthorhombic boxes.\r\n\r\n### Create the OpenMM system\r\n\r\nThis command creates an OpenMM `System` object from the information stored in `ala2_solv`. It contains multiple `Force` instances for the bonds, angles, periodic torsions, improper torsions, Urey-Bradley forces, CMAP potentials, and nonbonded (electrostatic and van der Waals) interactions.  It is in this function that we define the potential parameters we want to use. In this example, we have chosen the default values for each parameter except the ones specified. In particular:\r\n* `params` is the parameter set we defined: this is necessary to apply parameters to your system.\r\n* `nonbondedMethod=app.PME` indicates we want to include the full electrostatic interactions using the Particle Mesh Ewald method\r\n* `nonbondedCutoff=10.0*u.angstroms` indicates we want to truncate van der Waals interactions and the direct-space sum in PME to 10 angstroms.\r\n* `constraints=app.HBonds` indicates that we want to constrain all bonds in which at least one atom is hydrogen\r\n\r\nSee the API documentation for the `chemistry` package ([available here](../../chemistry/chemistry.charmm.html#module-chemistry.charmm.openmmloader)) for a full listing of available options (such as using a switching function for van der Waals interactions with the `switchDistance` keyword).  If there are any other force objects you want to define, they can be added to the system after this step (like, for instance, positional restraints to a reference structure).\r\n\r\n### Create the integrator to do Langevin Dynamics\r\n\r\nIn this stage we specify an integrator. Common choices are `LangevinIntegrator` (as we've chosen here) to do simulations in the NVT ensemble and `VerletIntegrator` that allows us to do simulations either at constant energy or temperature if using the `AndersenThermostat`.  In this example, we've chosen the Langevin integrator with a target temperature of 300 K, a friction coefficient of 1/ps and a time step of 2 fs.\r\n\r\n### Define the platform\r\n\r\nIn this stage, we define the platform we want to use.  In this example we have chosen the CUDA platform, but this may not be available on every machine since it only runs on NVidia GPU hardware.  Other choices are OpenCL (which will run on a variety of GPUs including those made by AMD/ATI and CPUs), CPU (which is an optimized version that runs natively on CPUs), and Reference (often quite slow).\r\n\r\nThe properties can be set for each platform. In this case, we specified that we wanted to use a mixed precision model (a good compromise between speed and precision).\r\n\r\n### Create the Simulation object\r\n\r\nThis step creates a `Simulation` object that will be used to run the actual simulations.  If we wanted OpenMM to simply pick the fastest platform for us (rather than specify one directly), we could omit the \r\n`platform` and `prop` arguments.\r\n\r\n### Set the particle positions\r\n\r\nThis stage is very important.  In this step, we set the particle positions stored in the `ala2_crds` object to our object.  If you omit this step, you can get strange results or other errors like segmentation violations.  These particle positions have been parsed from the CHARMM coordinate file, but you could use a `PDBFile` or `CharmmRstFile` (restart file) instead.\r\n\r\n### Minimize the energy\r\n\r\nThis stage performs a basic energy minimization to relax particle positions.  This particular invocation will perform at most 500 iterations.\r\n\r\n### Set up the reporters\r\n\r\nThis stage defines reporters that will \"report\" on the status of the simulation periodically throughout the simulation. The first is an `AKMAStateDataReporter` which will print out a summary of energies and temperatures every 100 steps.  Unlike the `StateDataReporter` in OpenMM, this reporter prints values in the AKMA unit system (Angstrom, Kilocalorie per mole, and atomic mass units).  This reporter directs the printout to standard output (the screen), `sys.stdout` can be replaced with a different file-like object or a file name.\r\n\r\nThe second reporter is a DCD trajectory reporter, which is written in the standard DCD trajectory format.\r\n\r\n### Running dynamics\r\n\r\nThis is the stage that actually runs the MD.  In this case, we are running 10,000 steps of MD.  The wiki page with \"Common recipes\" has information regarding running a long simulation in chunks.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}